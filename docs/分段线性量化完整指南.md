# 分段线性量化完整指南

## 符号约定

在开始之前，先统一本文使用的符号：

| 符号 | 含义 | 示例 |
|------|------|------|
| `x`, `y` | 浮点域的输入/输出 | `x = 0.1`, `y = 0.525` |
| `q_x`, `q_y` | 量化后的输入/输出 | `q_x = 24986`, `q_y = 34402` |
| `q_b`, `q_c` | 量化后的线性系数 | `q_b = 32619` |
| `zp_x`, `zp_y` | 输入/输出的 zero-point | `zp_x = 24576` |
| `scale_x`, `scale_y` | 输入/输出的缩放因子 | `scale_x = 2^-12` |
| `shift_bits_*` | 移位位数，`scale = 2^(-shift_bits)` | `shift_bits_x = 12` |
| `n_BX_total` | 融合后的总移位位数 | `n_BX_total = 13` |
| `term_c_precomputed` | 预计算的常数项 | `term_c_precomputed = 32770` |

---

## 一、核心思想

### 1.1 问题背景

在量化神经网络中，我们需要在**整数域**计算激活函数（如 Sigmoid、Tanh），而不能使用浮点运算。

**传统方法**：查表法（LUT）
- 优点：简单直接
- 缺点：内存占用大（256个值），精度有限

**分段线性拟合方法**：
- 将激活函数分成多段（如32段）
- 每段用线性函数 `y = b·x + c` 近似
- 在整数域计算，无需浮点运算

### 1.2 方法示意图

```
        Sigmoid 函数                    分段线性近似
           │                               │
     1.0 ──┼─────────────────        1.0 ──┼─────────────────
           │           ****                │           ****
           │        ***                    │        ***
     0.5 ──┼─────**─────────         0.5 ──┼─────**─────────
           │   **                          │   **
           │***                            │***
     0.0 ──┼─────────────────        0.0 ──┼─────────────────
          -6    0    6                    -6    0    6
                                          ↑  ↑  ↑
                                      每段用 y = bx + c 近似
```

### 1.3 数学原理

**浮点域**：Sigmoid 函数
```
y = sigmoid(x) = 1 / (1 + exp(-x))
```

**分段线性近似**：
```
y ≈ b_i · x + c_i  （对于第 i 段）
```

其中 `b_i` 和 `c_i` 通过最小二乘法拟合得到。

---

## 二、关键概念

### 2.1 量化的本质

**量化**：将浮点数映射到整数，减少存储和计算开销。

```
浮点值 x  ──量化──→  整数 q_x  ──反量化──→  近似浮点值 x'
```

**量化公式**：
```
q = round(x / scale) + zp
```

**反量化公式**：
```
x = scale · (q - zp)
```

### 2.2 为什么用 2 的幂次方 Scale？

本方案使用 `scale = 2^(-shift_bits)`，而非任意浮点数。

**原因**：乘以 `2^(-n)` 等价于右移 `n` 位，**移位操作比乘除法快得多**！

```
x / scale = x / 2^(-n) = x · 2^n  →  在整数域：q >> n 或 q << n
```

### 2.3 Zero-point 的作用

Zero-point（零点）用于处理**负数**。

**问题**：UINT16 只能表示 0~65535，如何表示负数？

**解决**：引入 zero-point，让 0 对应某个正整数。

```
例：x ∈ [-6, 6]，使用 UINT16 量化
- zp_x = 24576（代表浮点 0）
- x = -6 → q_x = 0
- x = 0  → q_x = 24576
- x = 6  → q_x = 49152
```

### 2.4 "烘焙"是什么？

**烘焙（Baking）**：将运行时的计算**提前到拟合阶段**完成，存储预计算结果。

**示例**：输出 zero-point 的烘焙

```
原始公式：
  y = b·x + c
  q_y = round(y / scale_y) + zp_y  ← 运行时需要加 zp_y

烘焙后：
  c_adjusted = c + zp_y · scale_y  ← 拟合阶段计算
  q_c = round(c_adjusted / scale_c)
  
  运行时：q_y = ... + term_c_precomputed  ← 已包含 zp_y 效果，无需额外操作
```

**优势**：减少运行时计算，提高效率。

---

## 三、量化参数详解

### 3.1 输入量化

输入 `x` 被量化为 `q_x`：
```
q_x = round(x / scale_x) + zp_x
```

**示例**（Sigmoid 输入）：
| 参数 | 值 | 说明 |
|------|------|------|
| 浮点范围 | x ∈ [-6, 6] | Sigmoid 有效范围 |
| scale_x | 2^-12 = 0.000244 | 精度约 0.0002 |
| shift_bits_x | 12 | scale = 2^(-12) |
| zp_x | 24576 | 使 x=0 对应 q_x=24576 |
| 量化范围 | q_x ∈ [0, 49152] | UINT16 |

**计算示例**：
```
x = 0.1
q_x = round(0.1 / 2^-12) + 24576
    = round(409.6) + 24576
    = 410 + 24576
    = 24986
```

### 3.2 输出量化

输出 `y` 的量化参数：

**示例**（Sigmoid 输出）：
| 参数 | 值 | 说明 |
|------|------|------|
| 浮点范围 | y ∈ [0, 1] | Sigmoid 输出范围 |
| scale_y | 2^-16 = 0.0000153 | 高精度 |
| shift_bits_y | 16 | scale = 2^(-16) |
| zp_y | -1 | 使输出更精确 |
| 量化范围 | q_y ∈ [0, 65535] | UINT16 |

### 3.3 系数量化

线性拟合系数 `b` 和 `c` 也需要量化：

**系数 b**（对称量化，zp=0）：
```
q_b = round(b / scale_b)
```

**系数 c**（烘焙输出 zero-point）：
```
c_adjusted = c + zp_y · scale_y    ← 烘焙 zp_y
q_c = round(c_adjusted / scale_c)
```

---

## 四、整数域计算推导

### 4.1 目标

**浮点域计算**：
```
y = b · x + c
```

**量化域目标**：找到只用整数运算的等价公式
```
q_y = f(q_x, q_b, q_c, ...)  ← 只用整数运算！
```

### 4.2 完整推导

**步骤1：用量化值表示浮点值**
```
x = scale_x · (q_x - zp_x)
b = scale_b · q_b              （对称量化，zp_b = 0）
c = scale_c · q_c_adjusted     （已烘焙 zp_y）
```

**步骤2：代入 y = b·x + c**
```
y = b · x + c
  = (scale_b · q_b) · (scale_x · (q_x - zp_x)) + (scale_c · q_c)
  = scale_b · scale_x · q_b · (q_x - zp_x) + scale_c · q_c
```

**步骤3：量化输出（因为 c 已烘焙 zp_y，所以不需要再加）**
```
q_y = round(y / scale_y)
    = round((scale_b · scale_x · q_b · (q_x - zp_x) + scale_c · q_c) / scale_y)
```

**步骤4：分离两项**
```
q_y = round(scale_b · scale_x / scale_y · q_b · (q_x - zp_x))
    + round(scale_c / scale_y · q_c)
```

**步骤5：用移位代替除法**

由于 `scale = 2^(-shift_bits)`：
```
scale_b · scale_x / scale_y = 2^(-shift_bits_b) · 2^(-shift_bits_x) / 2^(-shift_bits_y)
                            = 2^(-(shift_bits_b + shift_bits_x - shift_bits_y))
```

**定义融合移位位数**：
```
n_BX_total = shift_bits_b + shift_bits_x - shift_bits_y
```

### 4.3 最终公式

```
┌─────────────────────────────────────────────────────────────────┐
│  q_y = (q_b · (q_x - zp_x)) >> n_BX_total + term_c_precomputed  │
└─────────────────────────────────────────────────────────────────┘
```

其中：
- `n_BX_total = shift_bits_b + shift_bits_x - shift_bits_y`
- `term_c_precomputed = q_c >> n_yc`（拟合阶段预计算）
- `n_yc = shift_bits_c - shift_bits_y`

**注意**：如果移位位数为负，则执行左移 `<<`。

---

## 五、优化策略

### 5.1 移位融合优化

**未优化**（两步移位）：
```
                              步骤多，效率低
                                    ↓
bx_32 = q_b · (q_x - zp_x)        // 乘法
q_bx = bx_32 >> n_bx              // 第一步：对齐到 bx 域
term_bx = q_bx >> n_yb            // 第二步：对齐到 y 域
```

**优化后**（一步移位）：
```
bx_32 = q_b · (q_x - zp_x)        // 乘法
term_bx = bx_32 >> n_BX_total     // 融合移位：一步到位！
```

**原理**：
```
n_BX_total = n_bx + n_yb
           = (shift_bits_b + shift_bits_x - shift_bits_bx) + (shift_bits_bx - shift_bits_y)
           = shift_bits_b + shift_bits_x - shift_bits_y
```

中间的 `shift_bits_bx` 相互抵消，所以可以跳过 bx 中间域！

### 5.2 常数项预计算优化

**未优化**（运行时计算）：
```
term_c = q_c >> n_yc    // 每次运行都要计算
```

**优化后**（预计算）：
```
term_c_precomputed = q_c >> n_yc  // 拟合阶段计算一次，存入 LUT
```

### 5.3 优化效果对比

| 操作 | 未优化 | 优化后 |
|------|--------|--------|
| 移位次数 | 3次 | 1次 |
| 运行时加法 | 2次 | 1次 |
| LUT 存储 | q_b, q_c, n_bx, n_yb, n_yc | q_b, n_BX_total, term_c_precomputed |

---

## 六、完整计算流程

### 6.1 数据流图

```
输入: q_x (UINT16)
  │
  ▼
┌─────────────────────────────────────────────────────────────────┐
│ 步骤1: 段查找                                                    │
│   比较 q_x 与阈值数组，确定 segment_id                            │
│   例: q_x = 24986 → Segment 8                                   │
└─────────────────────────────────────────────────────────────────┘
  │
  ▼
┌─────────────────────────────────────────────────────────────────┐
│ 步骤2: 参数读取（从 LUT）                                         │
│   - q_b (INT16): 量化斜率                                        │
│   - n_BX_total (INT8): 融合移位位数                               │
│   - term_c_precomputed (INT32): 预计算常数项（已含 zp_y）          │
└─────────────────────────────────────────────────────────────────┘
  │
  ▼
┌─────────────────────────────────────────────────────────────────┐
│ 步骤3: 去零点                                                    │
│   x_offset = q_x - zp_x  (INT16)                                │
│   例: 24986 - 24576 = 410                                       │
└─────────────────────────────────────────────────────────────────┘
  │
  ▼
┌─────────────────────────────────────────────────────────────────┐
│ 步骤4: 乘法 + 融合移位                                           │
│   bx_32 = q_b × x_offset  (INT32)                               │
│   term_bx = bx_32 >> n_BX_total                                 │
│   例: 32619 × 410 = 13373790 >> 13 = 1632                       │
└─────────────────────────────────────────────────────────────────┘
  │
  ▼
┌─────────────────────────────────────────────────────────────────┐
│ 步骤5: 相加                                                      │
│   y_32 = term_bx + term_c_precomputed  (INT32)                  │
│   例: 1632 + 32770 = 34402                                      │
└─────────────────────────────────────────────────────────────────┘
  │
  ▼
┌─────────────────────────────────────────────────────────────────┐
│ 步骤6: 饱和                                                      │
│   q_y = clip(y_32, 0, 65535)  (UINT16)                          │
│   例: clip(34402, 0, 65535) = 34402                             │
└─────────────────────────────────────────────────────────────────┘
  │
  ▼
输出: q_y (UINT16)
```

### 6.2 数据类型说明

| 变量 | 数据类型 | 范围 | 说明 |
|------|---------|------|------|
| q_x | UINT16 | 0~65535 | 量化输入 |
| zp_x | INT16/UINT16 | - | 输入零点 |
| x_offset | INT16 | -32768~32767 | 去零点后可能为负 |
| q_b | INT16 | -32768~32767 | 斜率可正可负 |
| bx_32 | INT32 | - | 乘法结果，避免溢出 |
| term_c_precomputed | INT32 | - | 预计算常数项 |
| y_32 | INT32 | - | 加法结果 |
| q_y | UINT16 | 0~65535 | 量化输出 |

---

## 七、完整示例

### 7.1 任务：计算 sigmoid(0.1)

**已知参数**：

| 类别 | 参数 | 值 |
|------|------|------|
| 输入量化 | scale_x | 2^-12 |
| | shift_bits_x | 12 |
| | zp_x | 24576 |
| 输出量化 | scale_y | 2^-16 |
| | shift_bits_y | 16 |
| | zp_y | -1 |
| Segment 8 | 浮点系数 b | 0.248864 |
| | 浮点系数 c | 0.500052 |
| | q_b | 32619 |
| | n_BX_total | 13 |
| | term_c_precomputed | 32770 |

### 7.2 计算过程

```
输入: x = 0.1

步骤1: 输入量化
  q_x = round(0.1 / 2^-12) + 24576
      = round(409.6) + 24576
      = 24986

步骤2: 段查找
  q_x = 24986 → 属于 Segment 8

步骤3: 去零点
  x_offset = q_x - zp_x
           = 24986 - 24576
           = 410

步骤4: 乘法 + 融合移位
  bx_32 = q_b × x_offset
        = 32619 × 410
        = 13,373,790

  term_bx = bx_32 >> n_BX_total
          = 13,373,790 >> 13
          = 1632

步骤5: 相加
  y_32 = term_bx + term_c_precomputed
       = 1632 + 32770
       = 34402

步骤6: 饱和
  q_y = clip(34402, 0, 65535)
      = 34402

验证: 反量化
  y = scale_y × (q_y - zp_y)
    = 2^-16 × (34402 - (-1))
    = 2^-16 × 34403
    = 0.5249

真实值: sigmoid(0.1) = 0.5250
误差: |0.5249 - 0.5250| = 0.0001 ✓ 
```

### 7.3 计算流程图示

```
x = 0.1
    │
    ▼ 量化
q_x = 24986
    │
    ▼ 去零点
x_offset = 410
    │
    ├──────────────────┐
    ▼                  ▼
  × q_b          term_c_precomputed
  × 32619             32770
    │                  │
    ▼                  │
bx_32 = 13,373,790     │
    │                  │
    ▼ >> 13            │
term_bx = 1632         │
    │                  │
    └───────┬──────────┘
            ▼ 相加
       y_32 = 34402
            │
            ▼ 饱和
       q_y = 34402
            │
            ▼ 反量化
        y = 0.5249 ≈ sigmoid(0.1) ✓
```

---

## 八、不同位宽配置

根据精度和性能需求，可选择不同位宽：

### 8.1 INT16 配置（默认，平衡精度与性能）

| 参数 | 数据类型 | 存储大小 |
|------|---------|---------|
| segment_id | INT8 | 1 byte |
| zp_x | INT16 | 2 bytes |
| q_b | INT16 | 2 bytes |
| n_BX_total | INT8 | 1 byte |
| term_c_precomputed | INT32 | 4 bytes |
| **每段总计** | | **10 bytes** |

### 8.2 INT8 配置（低精度，高性能）

| 参数 | 数据类型 | 存储大小 |
|------|---------|---------|
| segment_id | INT8 | 1 byte |
| zp_x | INT8 | 1 byte |
| q_b | INT8 | 1 byte |
| n_BX_total | INT8 | 1 byte |
| term_c_precomputed | INT16 | 2 bytes |
| **每段总计** | | **6 bytes** |

### 8.3 INT32 配置（高精度）

| 参数 | 数据类型 | 存储大小 |
|------|---------|---------|
| segment_id | INT8 | 1 byte |
| zp_x | INT32 | 4 bytes |
| q_b | INT32 | 4 bytes |
| n_BX_total | INT8 | 1 byte |
| term_c_precomputed | INT64 | 8 bytes |
| **每段总计** | | **18 bytes** |

---

## 九、设计原理总结

### 9.1 为什么用 2 的幂次方 Scale？

| 优势 | 说明 |
|------|------|
| 硬件友好 | 移位操作比除法快 10-100 倍 |
| 精度可控 | 调整 shift_bits 即可改变精度 |
| 实现简单 | 只需移位，无需浮点单元 |

### 9.2 为什么分段？

| 优势 | 说明 |
|------|------|
| 精度提升 | 线性函数在局部区域更准确 |
| 内存效率 | 32段 × 10字节 = 320字节，比 65536 值 LUT 小得多 |
| 计算简单 | 只需一次乘法和一次加法 |

### 9.3 为什么融合移位？

| 优势 | 说明 |
|------|------|
| 性能优化 | 减少一次移位操作 |
| 代码简化 | 减少中间变量 |
| 精度保持 | 数学等价，不损失精度 |

### 9.4 为什么预计算 term_c？

| 优势 | 说明 |
|------|------|
| 性能优化 | 运行时直接查表，无需计算 |
| 精度保证 | 拟合阶段精确计算，避免累积误差 |

---

## 十、常见问题

### Q1: 为什么输出 zero-point 是 -1？

A: 这是拟合优化的结果。`zp_y = -1` 可以更好地覆盖 Sigmoid 的输出范围 [0, 1]，减少量化误差。

### Q2: 如果 n_BX_total 为负怎么办？

A: 执行左移操作 `<<`。例如 `n_BX_total = -2` 时：
```
term_bx = bx_32 << 2  （左移 2 位）
```

### Q3: 为什么 term_c_precomputed 需要 INT32？

A: 因为 `q_c << (-n_yc)` 可能产生较大的值。例如示例中：
```
term_c_precomputed = 16385 << 1 = 32770
```
虽然这个值在 INT16 范围内，但其他段可能更大，用 INT32 更安全。

### Q4: 段查找是怎么实现的？

A: 通常使用二分查找或线性查找。对于 32 段，线性查找（循环比较）在硬件上可能更高效。

---

## 十一、总结

### 核心公式

```
┌─────────────────────────────────────────────────────────────────┐
│  q_y = (q_b · (q_x - zp_x)) >> n_BX_total + term_c_precomputed  │
└─────────────────────────────────────────────────────────────────┘
```

### 关键点

1. **分段近似**：将非线性函数分成多段，每段用 `y = bx + c` 近似
2. **整数计算**：所有运算在整数域进行，用移位代替除法
3. **优化策略**：移位融合 + 常数项预计算，减少运行时开销
4. **精度保证**：合理选择分段数和量化位宽，误差可控

### 应用场景

- ✅ 硬件加速器（FPGA、ASIC）
- ✅ 嵌入式部署（无浮点单元）
- ✅ 低功耗设备
- ✅ 实时推理系统
