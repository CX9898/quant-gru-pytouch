# 量化流程说明

## 核心原理

**分段线性拟合 + 2的幂次方量化**

- 输入/输出/bx：无符号量化（UINT16），负数通过 zero-point 处理
- 权重 b/c：有符号量化（INT16），对称量化
- 公式：`y = bx + c`（线性拟合）

## 量化流程（以 Sigmoid Segment 8 为例）

### 1. 量化参数

**输入量化器**（x ∈ [-6, 6]）:
- Scale: `2^-12 = 0.000244140625`
- Zero-point: `24576`
- 量化公式: `q_x = round(x / scale) + 24576`

**输出量化器**（y ∈ [0, 1]）:
- Scale: `2^-16 = 0.0000152587890625`
- Zero-point: `-1`
- 反量化公式: `y = scale * (q_y - (-1))`

**Segment 8 参数**:
- 浮点范围: `x ∈ [-0.006, 0.246]`
- 系数: `b = 0.248864`, `c = 0.500052`
- 量化系数: `q_b = 32619`, `q_c = 16385`
- 右移位数: `n_bx = 9`, `n_yb = 4`, `n_yc = -1`
- bx zero-point: `z_bx = 1276`

### 2. 计算示例（x = 0.1）

**步骤1：输入量化**
```
x = 0.1
q_x = round(0.1 / 2^-12) + 24576
   = round(409.6) + 24576
   = 24986
```

**步骤2：去零点**
```
x_offset = q_x - z_x = 24986 - 24576 = 410
```

**步骤3：计算 bx**
```
bx_32 = q_b * x_offset = 32619 * 410 = 13373790 (INT32)
q_bx = bx_32 >> n_bx = 13373790 >> 9 = 26120 (INT32, 去零点后的值)
注意: q_bx 是去零点后的值，不是带zero_point的量化值！
```

**步骤4：对齐到输出域并相加**
```
term_bx = q_bx >> n_yb = 26120 >> 4 = 1632
term_c = q_c << (-n_yc) = 16385 << 1 = 32770
y_32 = term_bx + term_c = 1632 + 32770 = 34402
```

**步骤5：饱和并反量化**
```
q_y = clip(34402, 0, 65535) = 34402
y = scale_y * (q_y - z_y) = 2^-16 * (34402 - (-1)) = 0.5249
```

**真实值**: `sigmoid(0.1) = 0.5250` ✓

### 数据流图

```
输入: q_x (UINT16), scale=2^(-n_x), zero_point=z_x
  ↓
[1. 段查找]
  比较 q_x 与阈值数组，确定 segment_id
  ↓
[2. 参数读取]
  从LUT读取: q_b (INT16), q_c (INT16), n_bx, n_yb, n_yc
  注: q_c 已烘焙输出 zero_point (c_adjusted = c + z_y * scale_y)
  ↓
[3. 去零点]
  x_offset = q_x - z_x (INT16)
  说明: 
  - 对于 sigmoid: x ∈ [-6, 6], q_x ∈ [0, 49152], z_x = 24576
  - x_offset = q_x - z_x ∈ [-24576, 24576] ✓ (在 INT16 范围内)

  ↓
[4. 乘法]
  bx_32 = q_b × x_offset (INT32)
  说明: INT16 × INT32 → INT32，最大值可达 32767 × 40959 ≈ 1.34×10^9，必须用 INT32
  ↓
[5. 移位对齐到 bx 量化域]
  公式: n_bx = n_b + n_x - n_BX
  其中: n_b 为 b 的 shift_bits, n_x 为输入的 shift_bits, n_BX 为 bx 的 shift_bits
  q_bx = bx_32 >> n_bx (INT32, 去零点后)， 这里是因为零点大
  说明: 即使右移，q_bx 的零点很大，需要 INT32
  ↓
[6. 计算 y = bx + c]
  公式: n_yb = n_BX - n_y, n_yc = n_c - n_y
  其中: n_BX 为 bx 的 shift_bits, n_c 为 c 的 shift_bits, n_y 为输出的 shift_bits
  注意: n_yb ≠ n_bx - n_y (n_bx 是右移位数，n_BX 是 shift_bits)
  ├─ term_bx = q_bx >> n_yb (INT32, 并行)
     - 理论上可用 INT16（如示例：26120 >> 4 = 1632），但代码用 INT32 统一类型
  ├─ term_c = q_c >> n_yc (INT32, 并行，n_yc 可能为负导致左移)
     - 理论上可用 INT16（如示例：16385 << 1 = 32770），但代码用 INT32 统一类型
  └─ y_32 = term_bx + term_c (INT32, 已包含 zero_point，因为 c 已烘焙)
  说明: 
  - 虽然 term_bx 和 term_c 的数值可能在 INT16 范围内，但代码统一用 INT32
  - 原因：1) 统一数据类型避免转换 2) 加法操作需要 INT32 3) 某些情况下可能超出 INT16
  ↓
[7. 饱和]
  q_y = clip(y_32, 0, 65535) (UINT16)
  ↓
输出: q_y (UINT16), scale=2^(-n_y), zero_point=z_y
```

# 量化流程说明

## 核心原理

**分段线性拟合 + 2的幂次方量化**

- 输入/输出/bx：无符号量化（UINT16），负数通过 zero-point 处理
- 权重 b/c：有符号量化（INT16），对称量化
- 公式：`y = bx + c`（线性拟合）

## 量化流程（优化后版本）

### 核心公式

**最终量化输出公式**：
```
q_y = (q_b · (q_x - z_x)) >> n_BX_total + term_c_precomputed
```

其中：
- `n_BX_total = n_bx + n_yb`（移位融合优化）
  - 如果 `n_BX_total ≥ 0`：右移 `>> n_BX_total`
  - 如果 `n_BX_total < 0`：左移 `<< (-n_BX_total)`
- `term_c_precomputed = q_c >> n_yc`（预计算优化）
  - 如果 `n_yc ≥ 0`：右移 `>> n_yc`
  - 如果 `n_yc < 0`：左移 `<< (-n_yc)`

#### Case 1: INT16
s (INT8)

zp_x (INT16)

q_b (INT16)

n_BX_total (INT8)

term_c_precomputed (INT32存储)

#### Case 2: INT8

s (INT8)

zp_x (INT8)

q_b (INT8)

n_BX_total (INT8)

term_c_precomputed ( INT16存储)


#### Case 3: INT32

s分段 (INT8)

zp_x (INT32)

q_b (INT32)

n_BX_total (INT8 存储，6bit有效， 符号位1左移0右移)

term_c_precomputed (INT64存储-->INT48存储)



### 数据流图（优化后）

```
输入: q_x (UINT16), scale=2^(-n_x), zero_point=z_x
  ↓
[1. 段查找]
  比较 q_x 与阈值数组，确定 segment_id
  ↓
[2. 参数读取]
  从LUT读取: q_b (INT16), n_BX_total, term_c_precomputed
  注: term_c_precomputed 已在拟合阶段预计算（包含 zero_point 烘焙）
  ↓
[3. 去零点]
  x_offset = q_x - z_x (INT16)
  ↓
[4. 乘法 + 移位融合]
  bx_32 = q_b × x_offset (INT32)
  term_bx = bx_32 >> n_BX_total (或左移，如果 n_BX_total < 0)
  说明: n_BX_total = n_bx + n_yb，融合了两步移位
  ↓
[5. 相加]
  y_32 = term_bx + term_c_precomputed (INT32)
  ↓
[6. 饱和]
  q_y = clip(y_32, 0, 65535) (UINT16)
  ↓
输出: q_y (UINT16), scale=2^(-n_y), zero_point=z_y
```

**优化说明**：
- ✅ **移位融合**：`n_BX_total = n_bx + n_yb`，减少一次移位操作
- ✅ **term_c 预计算**：拟合阶段计算 `term_c_precomputed = q_c << n_yc`，运行时直接查表

### 移位位数计算公式

**基础移位位数**：
- `n_bx = shift_bits_b + shift_bits_x - shift_bits_bx`
- `n_yb = shift_bits_bx - shift_bits_y`
- `n_yc = shift_bits_c - shift_bits_y`

**融合后的移位位数**：
- `n_BX_total = n_bx + n_yb = shift_bits_b + shift_bits_x - shift_bits_y`

**说明**：
- `shift_bits_*` 表示各量化器的 `shift_bits`（scale = 2^(-shift_bits)）
- 如果 `n_BX_total < 0`，则执行左移操作（`<<`）
- 如果 `n_yc < 0`，`term_c_precomputed` 使用左移计算
---
